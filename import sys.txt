import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QHeaderView
from PyQt5.QtCore import QThread, pyqtSignal, Qt, QAbstractTableModel, QModelIndex
from PyQt5.QtGui import QColor
from scapy.all import sniff, Ether, IP, TCP, UDP, ICMP, ARP, Raw
from datetime import datetime
from ui_pcapqt import Ui_PcapQt


class PacketTableModel(QAbstractTableModel):

    def __init__(self):
        super().__init__()
        self.packets = []
        self.headers = ['No.', 'Time', 'Source', 'Destination', 'Protocol', 'Length', 'Info']

    def rowCount(self, parent=QModelIndex()):
        return len(self.packets)

    def columnCount(self, parent=QModelIndex()):
        return len(self.headers)

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None

        packet_data = self.packets[index.row()]

        if role == Qt.DisplayRole:
            return packet_data[index.column()]
        elif role == Qt.BackgroundRole:
            protocol = packet_data[4]
            if protocol == 'TCP':
                return QColor(231, 230, 255)
            elif protocol == 'UDP':
                return QColor(218, 238, 255)
            elif protocol == 'ARP':
                return QColor(250, 240, 215)
            elif protocol == 'ICMP':
                return QColor(252, 224, 255)
        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return self.headers[section]
        return None

    def add_packet(self, packet_data):
        row = len(self.packets)
        self.beginInsertRows(QModelIndex(), row, row)
        self.packets.append(packet_data)
        self.endInsertRows()

    def clear(self):
        self.beginResetModel()
        self.packets.clear()
        self.endResetModel()


class PacketDetailModel(QAbstractTableModel):

    def __init__(self):
        super().__init__()
        self.details = []

    def rowCount(self, parent=QModelIndex()):
        return len(self.details)

    def columnCount(self, parent=QModelIndex()):
        return 2

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return None

        if role == Qt.DisplayRole:
            return self.details[index.row()][index.column()]
        elif role == Qt.BackgroundRole:
            field_name = self.details[index.row()][0]
            if field_name.startswith('==='):
                return QColor(220, 220, 220)
        return None

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return ['Field', 'Value'][section]
        return None

    def set_details(self, details):
        self.beginResetModel()
        self.details = details
        self.endResetModel()

    def clear(self):
        self.beginResetModel()
        self.details.clear()
        self.endResetModel()


class SnifferThread(QThread):

    packet_captured = pyqtSignal(object, dict)

    def __init__(self):
        super().__init__()
        self.is_running = False
        self.packet_count = 0
        self.start_time = None

    def run(self):
        self.is_running = True
        self.start_time = datetime.now()
        self.packet_count = 0

        def packet_handler(packet):
            if not self.is_running:
                return True

            self.packet_count += 1
            packet_info = self.parse_packet(packet)
            self.packet_captured.emit(packet, packet_info)

        try:
            sniff(prn=packet_handler, store=False, stop_filter=lambda x: not self.is_running)
        except Exception as e:
            print(f"Sniffing error: {e}")

    def parse_packet(self, packet):
        info = {
            'no': self.packet_count,
            'time': (datetime.now() - self.start_time).total_seconds(),
            'src': 'Unknown',
            'dst': 'Unknown',
            'protocol': 'Unknown',
            'length': len(packet),
            'info': ''
        }

        if Ether in packet:
            info['src'] = packet[Ether].src
            info['dst'] = packet[Ether].dst

        if IP in packet:
            info['src'] = packet[IP].src
            info['dst'] = packet[IP].dst
            info['protocol'] = packet[IP].proto

            if TCP in packet:
                info['protocol'] = 'TCP'
                info['info'] = f"{packet[TCP].sport} → {packet[TCP].dport} [Flags: {packet[TCP].flags}]"
            elif UDP in packet:
                info['protocol'] = 'UDP'
                info['info'] = f"{packet[UDP].sport} → {packet[UDP].dport}"
            elif ICMP in packet:
                info['protocol'] = 'ICMP'
                info['info'] = f"Type: {packet[ICMP].type}"

        elif ARP in packet:
            info['protocol'] = 'ARP'
            info['src'] = packet[ARP].psrc
            info['dst'] = packet[ARP].pdst
            info['info'] = f"Who has {packet[ARP].pdst}? Tell {packet[ARP].psrc}"

        return info

    def stop(self):
        self.is_running = False

class PcapQt(QMainWindow):
    def __init__(self):
        super().__init__()
        self.ui = Ui_PcapQt()
        self.ui.setupUi(self)

        self.packet_model = PacketTableModel()
        self.detail_model = PacketDetailModel()

        self.ui.packageTableView.setModel(self.packet_model)
        self.ui.detailedPackageTableView.setModel(self.detail_model)

        self.ui.packageTableView.horizontalHeader().setStretchLastSection(True)
        self.ui.packageTableView.setSelectionBehavior(self.ui.packageTableView.SelectRows)
        self.ui.packageTableView.setSelectionMode(self.ui.packageTableView.SingleSelection)
        self.ui.packageTableView.setAlternatingRowColors(True)

        self.ui.detailedPackageTableView.horizontalHeader().setStretchLastSection(True)
        self.ui.detailedPackageTableView.verticalHeader().setVisible(False)
        self.ui.detailedPackageTableView.setAlternatingRowColors(True)

        self.sniffer = SnifferThread()
        self.sniffer.packet_captured.connect(self.on_packet_captured)

        self.raw_packets = []
        self.current_packet_index = -1

        self.ui.startCapture.toggled.connect(self.toggle_capture)
        self.ui.restartButton.clicked.connect(self.restart_capture)
        self.ui.packageTableView.selectionModel().currentRowChanged.connect(self.on_packet_selected)
        self.ui.previousPakageButton.clicked.connect(self.go_to_previous)
        self.ui.nextPakageButton.clicked.connect(self.go_to_next)
        self.ui.firstPakageButton.clicked.connect(self.go_to_first)
        self.ui.lastPakageButton.clicked.connect(self.go_to_last)

    def toggle_capture(self, checked):
        if checked:
            self.sniffer.start()
            self.ui.startCapture.setToolTip("Stop capturing")
        else:
            self.sniffer.stop()
            self.ui.startCapture.setToolTip("Start capturing")

    def restart_capture(self):
        if self.sniffer.isRunning():
            self.sniffer.stop()
            self.sniffer.wait()

        self.packet_model.clear()
        self.detail_model.clear()
        self.raw_packets.clear()
        self.current_packet_index = -1

        if self.ui.startCapture.isChecked():
            self.ui.startCapture.setChecked(False)

    def on_packet_captured(self, packet, packet_info):
        self.raw_packets.append(packet)

        packet_data = [
            packet_info['no'],
            f"{packet_info['time']:.6f}",
            packet_info['src'],
            packet_info['dst'],
            packet_info['protocol'],
            packet_info['length'],
            packet_info['info']
        ]

        self.packet_model.add_packet(packet_data)

        last_row = self.packet_model.rowCount() - 1
        self.ui.packageTableView.scrollTo(self.packet_model.index(last_row, 0))

    def on_packet_selected(self, current, previous):
        if not current.isValid():
            return

        row = current.row()
        self.current_packet_index = row

        if row < len(self.raw_packets):
            packet = self.raw_packets[row]
            self.display_packet_details(packet)

    def display_packet_details(self, packet):
        details = []

        details.append(['=== Frame ===', ''])
        details.append(['Frame Number', self.current_packet_index + 1])
        details.append(['Frame Length', f"{len(packet)} bytes"])
        details.append(['Capture Length', f"{len(packet)} bytes"])

        if Ether in packet:
            details.append(['=== Ethernet II ===', ''])
            details.append(['Destination MAC', packet[Ether].dst])
            details.append(['Source MAC', packet[Ether].src])
            details.append(['Type', f"{hex(packet[Ether].type)} ({packet[Ether].type})"])

        if IP in packet:
            details.append(['=== Internet Protocol ===', ''])
            details.append(['Version', packet[IP].version])
            details.append(['Header Length', f"{packet[IP].ihl * 4} bytes"])
            details.append(['Type of Service', f"0x{packet[IP].tos:02x}"])
            details.append(['Total Length', f"{packet[IP].len} bytes"])
            details.append(['Identification', f"0x{packet[IP].id:04x} ({packet[IP].id})"])
            details.append(['Flags', str(packet[IP].flags)])
            details.append(['Fragment Offset', packet[IP].frag])
            details.append(['Time to Live', packet[IP].ttl])
            details.append(['Protocol', f"{packet[IP].proto} ({self.get_protocol_name(packet[IP].proto)})"])
            details.append(['Header Checksum', f"0x{packet[IP].chksum:04x}"])
            details.append(['Source IP', packet[IP].src])
            details.append(['Destination IP', packet[IP].dst])

        if TCP in packet:
            details.append(['=== Transmission Control Protocol ===', ''])
            details.append(['Source Port', packet[TCP].sport])
            details.append(['Destination Port', packet[TCP].dport])
            details.append(['Sequence Number', packet[TCP].seq])
            details.append(['Acknowledgment Number', packet[TCP].ack])
            details.append(['Header Length', f"{packet[TCP].dataofs * 4} bytes"])
            details.append(['Flags', self.parse_tcp_flags(packet[TCP].flags)])
            details.append(['Window Size', packet[TCP].window])
            details.append(['Checksum', f"0x{packet[TCP].chksum:04x}"])
            details.append(['Urgent Pointer', packet[TCP].urgptr])

            if packet[TCP].options:
                details.append(['Options', str(packet[TCP].options)])

        elif UDP in packet:
            details.append(['=== User Datagram Protocol ===', ''])
            details.append(['Source Port', packet[UDP].sport])
            details.append(['Destination Port', packet[UDP].dport])
            details.append(['Length', f"{packet[UDP].len} bytes"])
            details.append(['Checksum', f"0x{packet[UDP].chksum:04x}"])

        elif ICMP in packet:
            details.append(['=== Internet Control Message Protocol ===', ''])
            details.append(['Type', f"{packet[ICMP].type} ({self.get_icmp_type(packet[ICMP].type)})"])
            details.append(['Code', packet[ICMP].code])
            details.append(['Checksum', f"0x{packet[ICMP].chksum:04x}"])

            if hasattr(packet[ICMP], 'id'):
                details.append(['Identifier', packet[ICMP].id])
            if hasattr(packet[ICMP], 'seq'):
                details.append(['Sequence Number', packet[ICMP].seq])

        if ARP in packet:
            details.append(['=== Address Resolution Protocol ===', ''])
            details.append(['Hardware Type', f"{packet[ARP].hwtype} (Ethernet)"])
            details.append(['Protocol Type', f"0x{packet[ARP].ptype:04x} (IPv4)"])
            details.append(['Hardware Size', packet[ARP].hwlen])
            details.append(['Protocol Size', packet[ARP].plen])
            details.append(['Operation', f"{packet[ARP].op} ({self.get_arp_op(packet[ARP].op)})"])
            details.append(['Sender MAC', packet[ARP].hwsrc])
            details.append(['Sender IP', packet[ARP].psrc])
            details.append(['Target MAC', packet[ARP].hwdst])
            details.append(['Target IP', packet[ARP].pdst])

        if Raw in packet:
            details.append(['=== Data ===', ''])
            raw_data = bytes(packet[Raw].load)
            details.append(['Data Length', f"{len(raw_data)} bytes"])

            preview_len = min(128, len(raw_data))
            hex_preview = ' '.join(f"{b:02x}" for b in raw_data[:preview_len])
            if len(raw_data) > preview_len:
                hex_preview += '...'
            details.append(['Data (hex)', hex_preview])

            ascii_preview = ''.join(chr(b) if 32 <= b < 127 else '.' for b in raw_data[:preview_len])
            if len(raw_data) > preview_len:
                ascii_preview += '...'
            details.append(['Data (ASCII)', ascii_preview])

        self.detail_model.set_details(details)
        self.ui.detailedPackageTableView.resizeColumnsToContents()

    def get_protocol_name(self, proto_num):
        protocols = {1: 'ICMP', 6: 'TCP', 17: 'UDP'}
        return protocols.get(proto_num, 'Unknown')

    def get_icmp_type(self, icmp_type):
        types = {
            0: 'Echo Reply',
            3: 'Destination Unreachable',
            8: 'Echo Request',
            11: 'Time Exceeded'
        }
        return types.get(icmp_type, 'Unknown')

    def get_arp_op(self, op):
        ops = {1: 'Request', 2: 'Reply'}
        return ops.get(op, 'Unknown')

    def parse_tcp_flags(self, flags):
        flag_list = []
        if flags & 0x01: flag_list.append('FIN')
        if flags & 0x02: flag_list.append('SYN')
        if flags & 0x04: flag_list.append('RST')
        if flags & 0x08: flag_list.append('PSH')
        if flags & 0x10: flag_list.append('ACK')
        if flags & 0x20: flag_list.append('URG')
        return ', '.join(flag_list) if flag_list else 'None'

    def go_to_previous(self):
        if self.current_packet_index > 0:
            new_index = self.current_packet_index - 1
            self.ui.packageTableView.selectRow(new_index)

    def go_to_next(self):
        if self.current_packet_index < len(self.raw_packets) - 1:
            new_index = self.current_packet_index + 1
            self.ui.packageTableView.selectRow(new_index)

    def go_to_first(self):
        if len(self.raw_packets) > 0:
            self.ui.packageTableView.selectRow(0)

    def go_to_last(self):
        if len(self.raw_packets) > 0:
            last_row = len(self.raw_packets) - 1
            self.ui.packageTableView.selectRow(last_row)

    def closeEvent(self, event):
        if self.sniffer.isRunning():
            self.sniffer.stop()
            self.sniffer.wait()
        event.accept()


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = PcapQt()
    window.show()
    sys.exit(app.exec_())